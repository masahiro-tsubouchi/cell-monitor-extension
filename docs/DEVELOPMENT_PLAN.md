# 開発計画：DB保存から可視化まで

このドキュメントは、AI駆動開発の原則に基づき、テスト駆動で「データベースへの保存」から「ダッシュボードでの可視化」までを実現するためのステップバイステップの開発計画です。

## フェーズ1: バックエンド基盤構築とデータ永続化

**ゴール：JupyterLabから送信された進捗データが、非同期でInfluxDBとPostgreSQLに永続化される状態。**

### ステップ1.1: 環境構築とDBセットアップ

- **タスク**:
  1. `docker-compose.yml` を更新し、`postgres`, `influxdb`, `redis` のサービス定義を追加します。
  2. InfluxDBとPostgreSQLの初期設定（DB名、ユーザー、パスワードなど）を行うための設定ファイルを用意します。
- **テストケース**:
  - `docker-compose up --build` を実行し、全コンテナがエラーなく起動することを確認します。
  - 各DBコンテナに `docker exec` で入り、CLIクライアント（`psql`, `influx`, `redis-cli`）で正常に接続できることを確認します。

### ステップ1.2: FastAPIのDB接続とモデル定義

- **タスク**:
  1. `fastapi_server/requirements.txt` に `sqlalchemy`, `psycopg2-binary`, `influxdb-client-python`, `redis` を追加します。
  2. FastAPIアプリケーション内に、各DBへの接続を管理するモジュールを作成します。
  3. SQLAlchemyを使い、PostgreSQLに保存するデータ（例: 生徒マスター情報）のテーブルモデルを定義します。
- **テストケース**:
  - DB接続部分をモックした単体テストを作成し、アプリケーション起動時にエラーが発生しないことを確認します。

### ステップ1.3: データ受信とRedisへの発行 (イベント発行)

- **タスク**:
  1. `/student-progress` エンドポイントを修正し、受信したデータを検証後、すぐにRedisのPub/Subチャネル（例: `progress-events`）にJSON形式で発行（Publish）します。
  2. DBへの直接の書き込み処理はこのエンドポイントから削除し、クライアントへの応答時間を最小限に抑えます。
- **テストケース**:
  - **単体テスト**: Redisクライアントをモックし、APIが呼ばれた際に `publish` メソッドが正しいチャネル名とデータで呼び出されることをアサートします。
  - **統合テスト**: 実際にRedisを起動した状態でAPIを叩き、`redis-cli` の `SUBSCRIBE` コマンドでデータがリアルタイムに発行されることを確認します。

### ステップ1.4: 非同期WorkerによるDB永続化

- **タスク**:
  1. Celeryのような非同期タスクキューを導入し、新しいWorkerコンテナを `docker-compose.yml` に追加します。
  2. Redisの `progress-events` チャネルを購読（Subscribe）する非同期タスクを定義します。
  3. タスク内で、受け取ったイベントデータをパースし、InfluxDB（全イベントログ）とPostgreSQL（関連マスター情報など）に書き込む処理を実装します。
- **テストケース**:
  - **単体テスト**: DBクライアントをモックし、特定のイベントデータを受け取った際に、InfluxDBとPostgreSQLへの書き込み処理が正しいデータで呼び出されることをアサートします。
  - **統合テスト**: `redis-cli` で手動でイベントを発行し、Workerコンテナのログを確認し、最終的に各DBにデータが正しく保存されていることをCLIで確認します。

---

## フェーズ2: リアルタイム通知機能の実装

**ゴール：DBへのデータ保存と同時に、WebSocket経由で接続中のクライアントにリアルタイムで更新が通知される状態。**

### ステップ2.1: WebSocketマネージャーの実装

- **タスク**:
  1. FastAPIに新しいWebSocketエンドポイント（例: `/ws/dashboard`）を追加します。
  2. 接続してきたクライアント（講師ダッシュボード）のWebSocket接続を管理する `ConnectionManager` クラスを実装します。
- **テストケース**:
  - Pythonの `websockets` ライブラリを使ったテストクライアントを作成し、FastAPIサーバーへの接続・切断が正常に行えることを確認します。

### ステップ2.2: RedisとWebSocketの連携

- **タスク**:
  1. `ConnectionManager` もRedisの `progress-events` チャネルを購読させます。
  2. 新しいイベントを受け取ったら、現在接続中の全てのクライアントに対して、そのイベントデータをWebSocket経由でブロードキャストします。
- **テストケース**:
  - **統合テスト**: テストクライアントをWebSocketに接続した状態で、`redis-cli` からイベントを発行します。クライアント側で、意図したデータがリアルタイムに受信できることをアサートします。

---

## フェーズ3: フロントエンドでの可視化

**ゴール：講師がブラウザ上のダッシュボードで、生徒の進捗をリアルタイムに確認できる状態。**

### ステップ3.1: ダッシュボードのプロトタイプ作成

- **タスク**:
  1. React, Vue, Svelteなどで新しいフロントエンドプロジェクトをセットアップします。
  2. アプリケーション起動時にFastAPIの `/ws/dashboard` エンドポイントに接続するロジックを実装します。
  3. WebSocket経由で受信したイベントデータを、画面上に単純なリストとしてリアルタイムで表示します。
- **テストケース**:
  - **手動E2Eテスト**: JupyterLabでセルを実行し、数秒以内にダッシュボードの表示が自動で更新されることを確認します。

### ステップ3.2: 分析APIとダッシュボードの連携

- **タスク**:
  1. 「クラス全体の進捗状況」や「生徒個別の詳細履歴」などを返すための集計APIをFastAPIに実装します。このAPIはInfluxDBやPostgreSQLからデータを取得します。
  2. ダッシュボードの初期表示時にこのAPIを呼び出し、過去のデータを表示する機能を実装します。
- **テストケース**:
  - **APIテスト**: FastAPIのテストクライアントを使い、集計APIがDBの状態に応じた正しいデータを返すことを確認します。
  - **自動E2Eテスト**: CypressやPlaywrightを導入し、「JupyterLabでセルを実行 → DBにデータ保存 → ダッシュボードにリアルタイム反映 → ページをリロード → 集計API経由でデータが正しく再表示される」という一連の流れを自動テストします。
