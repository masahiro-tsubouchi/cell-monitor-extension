{"version":3,"file":"lib_index_js.f07d95fa187ef96b5aa6.js","mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACuD;AACY;AAC6B;AACzF;AACP;AACA;AACA;AACA,wCAAwC;AACxC,gDAAgD;AAChD;AACA,sBAAsB,oDAAY;AAClC;AACA;AACA;AACA,yBAAyB,oDAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iEAAe;AACvB,oBAAoB,OAAO;AAC3B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D,aAAa;AACb;AACA;AACA,oFAAoF,kBAAkB;AACtG;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa,IAAI,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA,yBAAyB,oDAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAyB,2FAA2F,kHAAkH;AAClP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mCAAmC;AACvD;AACA,yBAAyB,oDAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAyB,6FAA6F,yBAAyB;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gBAAgB,oBAAoB;AACpC;AACA,YAAY,8DAAY,6BAA6B,iBAAiB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA,YAAY,8DAAY,uCAAuC,iBAAiB;AAChF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+DAAa;AAC5C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mCAAmC;AACnD;AACA,qBAAqB,oDAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,mCAAmC;AACnD;AACA,qBAAqB,oDAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0CAA0C;AAC1C,qCAAqC;;;;;;;;;;;;;;;;;AClhBwB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,sBAAsB,oDAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5SA;AACA;AACA;AACA;AACoD;AACe;AACX;AACO;AAC/D;AACyD;AACN;AAC0B;AACG;AAChF;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAY;AAClC;AACA;AACA,mCAAmC,kEAAe;AAClD,2CAA2C,sFAAuB;AAClE,gCAAgC,4DAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC,YAAY,gDAAY,aAAa,mBAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAY,+CAA+C,iBAAiB;AAC5F;AACA;AACA;AACA;AACA,YAAY,iEAAyB;AACrC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+DAAa;AAClD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAY,qBAAqB,iBAAiB,KAAK,iBAAiB;AACxF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAY,qBAAqB,iBAAiB,KAAK,iBAAiB;AACpF;AACA;AACA;AACA,gBAAgB,8CAA8C;AAC9D;AACA,YAAY,8DAAY,+BAA+B,kBAAkB,MAAM,iBAAiB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAgB,EAAE,yEAAgB,EAAE,8DAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;;;;;;ACxHzB;AACA;AACA;AACA;AAC0B;AAC0B;AACqC;AACrB;AACpE;AACA;AACA;AACA;AACO;AACP;AACA,sBAAsB,oDAAY;AAClC;AACA;AACA;AACA;AACA,2CAA2C,6EAAuB;AAClE;AACA;AACA,6BAA6B,mDAAY;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,mCAAmC,mDAAY;AAC/C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,8BAA8B,0BAA0B,GAAG,gBAAgB,GAAG,QAAQ;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,qCAAqC,4CAA4C;AACjF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,yBAAyB;AACvG;AACA,oBAAoB,8DAAY,6BAA6B,aAAa;AAC1E;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mEAA2B,kEAAkE,gDAAgD;AACjK;AACA;AACA;AACA,oBAAoB,0DAAkB,iDAAiD,QAAQ,GAAG,WAAW;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,wBAAwB;AAC3G;AACA;AACA;AACA;AACA;AACA,oBAAoB,mEAA2B,gEAAgE,+CAA+C;AAC9J;AACA;AACA;AACA,oBAAoB,0DAAkB,+CAA+C,QAAQ,GAAG,WAAW;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtMA;AACA;AACA;AACA;AAC+C;AACxC;AACP;AACA,sBAAsB,2DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU,GAAG,OAAO,GAAG,6BAA6B;AACpF;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACoD;AACZ;AACxC,eAAe,qDAAY;AAC3B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAA8E;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB,IAAI,aAAa,QAAQ,SAAS,EAAE,cAAc;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,gBAAgB,8DAAY;AAC5B;AACA;AACA,gBAAgB,8DAAY;AAC5B;AACA;AACA,gBAAgB,8DAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,8BAA8B;AAC9B;AACA,6BAA6B;AAC7B;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA,0BAA0B,eAAe;AACzC;AACA,0BAA0B,eAAe;AACzC;AACA,0BAA0B,eAAe;AACzC;AACA,0BAA0B,eAAe;AACzC;AACA,0BAA0B,eAAe;AACzC;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,WAAW;AACnF;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,qBAAqB;AACrB,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;ACtQA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mBAAmB,GAAG,MAAM,IAAI,UAAU;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB,GAAG,QAAQ;AACrD,SAAS;AACT;AACA;AACA;AACO;AACP;AACO;AACP;AACA;;;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL","sources":["webpack://cell-monitor/./lib/core/EventManager.js","webpack://cell-monitor/./lib/core/SettingsManager.js","webpack://cell-monitor/./lib/index.js","webpack://cell-monitor/./lib/services/DataTransmissionService.js","webpack://cell-monitor/./lib/services/LoadDistributionService.js","webpack://cell-monitor/./lib/utils/errorHandler.js","webpack://cell-monitor/./lib/utils/logger.js","webpack://cell-monitor/./lib/utils/uuid.js"],"sourcesContent":["/**\n * イベント管理クラス\n * JupyterLabのノートブックイベントを監視し、学習進捗データを収集・送信\n */\nimport { NotebookActions } from '@jupyterlab/notebook';\nimport { Notification, ToolbarButton } from '@jupyterlab/apputils';\nimport { generateUUID, createLogger, handleCellProcessingError, handleUIError } from '../utils';\nexport class EventManager {\n    constructor(notebookTracker, settingsManager, dataTransmissionService) {\n        this.executionHandlerRegistered = false;\n        this.helpSession = new Map();\n        this.helpIntervals = new Map(); // Phase 2.3: 継続HELP送信\n        this.helpSessionTimestamps = new Map(); // Phase 2.3: タイムスタンプ管理\n        this.processedCells = new Map();\n        this.logger = createLogger('EventManager');\n        this.notebookTracker = notebookTracker;\n        this.settingsManager = settingsManager;\n        this.dataTransmissionService = dataTransmissionService;\n        this.sessionId = generateUUID();\n    }\n    /**\n     * イベントハンドラを初期化\n     */\n    initialize() {\n        this.setupNotebookTracking();\n        this.setupExecutionTracking();\n    }\n    /**\n     * ノートブック関連イベントの追跡設定\n     */\n    setupNotebookTracking() {\n        this.notebookTracker.widgetAdded.connect((sender, widget) => {\n            const notebookPath = widget.context.path || 'unknown';\n            this.sendNotebookEvent('notebook_opened', notebookPath);\n            // 元のコードと同じように各ノートブックのツールバーにヘルプボタンを追加\n            this.addHelpButtonToNotebook(widget);\n        });\n    }\n    /**\n     * セル実行イベントの追跡設定（元のコードと同じ方式）\n     */\n    setupExecutionTracking() {\n        if (this.executionHandlerRegistered) {\n            return;\n        }\n        // 元のコードと同じ方式でNotebookActions.executed.connectを使用\n        NotebookActions.executed.connect((_, args) => {\n            const { cell } = args;\n            this.processCellExecution(cell);\n        });\n        this.executionHandlerRegistered = true;\n        this.logger.info('Cell execution handler registered (once)');\n    }\n    /**\n     * セル実行を処理（元のコードと完全に同じロジック）\n     */\n    processCellExecution(cell) {\n        var _a, _b;\n        try {\n            if (!cell || !cell.model)\n                return;\n            // 処理開始時間（パフォーマンス計測用）\n            const startTime = performance.now();\n            const cellId = cell.model.id;\n            // 重複処理防止機構（元のコードと同じ）\n            const currentTime = Date.now();\n            const lastTime = this.processedCells.get(cellId) || 0;\n            const rawTimeDiff = currentTime - lastTime;\n            const timeDiff = Math.max(0, Math.min(rawTimeDiff, 300000)); // 5分上限\n            // 異常値検出とログ出力\n            if (rawTimeDiff > 300000) {\n                this.logger.warn('Abnormal timestamp detected', {\n                    currentTime,\n                    lastTime,\n                    rawDiff: rawTimeDiff\n                });\n            }\n            this.logger.perfDebug('Cell execution processing', {\n                cellId,\n                timeSinceLastProcessing: timeDiff,\n                alreadyProcessed: this.processedCells.has(cellId),\n                memoryUsage: `${this.processedCells.size} / 50 max`\n            });\n            // 500ms以内の重複処理を防止（デバウンス）\n            if (timeDiff < 500 && this.processedCells.has(cellId)) {\n                this.logger.debug('Skipping duplicate cell execution processing', { cellId, timeDiff });\n                return;\n            }\n            // 処理済みマークを更新\n            this.processedCells.set(cellId, currentTime);\n            // 軽量メモリ管理（受講生PCの負荷最小化）\n            if (this.processedCells.size >= 50) { // 100→50に削減\n                // 重いソート処理を避け、最初のエントリを削除（FIFO方式）\n                const firstKey = this.processedCells.keys().next().value;\n                if (firstKey) {\n                    this.processedCells.delete(firstKey);\n                    this.logger.debug('Memory cleanup: removed oldest cell entry', {\n                        removedKey: firstKey,\n                        currentSize: this.processedCells.size\n                    });\n                }\n            }\n            // 安全にセルのコードを取得する方法\n            let code = '';\n            try {\n                if (cell.model.sharedModel && cell.model.sharedModel.source) {\n                    code = cell.model.sharedModel.source;\n                }\n                else if (cell.model.value && cell.model.value.text) {\n                    code = cell.model.value.text;\n                }\n                else if (cell.editor && cell.editor.model && cell.editor.model.value) {\n                    code = cell.editor.model.value.text;\n                }\n            }\n            catch (error) {\n                this.logger.warn('Failed to get cell code:', error);\n            }\n            // Get notebook widget from cell\n            const notebookWidget = this.notebookTracker.currentWidget;\n            if (!notebookWidget)\n                return;\n            // Get notebook path\n            const notebookPath = ((_a = notebookWidget.context) === null || _a === void 0 ? void 0 : _a.path) || '';\n            // Get cell index and type\n            let cellIndex = undefined;\n            let cellType = undefined;\n            try {\n                // セルのインデックスを取得\n                const cells = notebookWidget.content.widgets;\n                for (let i = 0; i < cells.length; i++) {\n                    if (cells[i].model.id === cellId) {\n                        cellIndex = i;\n                        break;\n                    }\n                }\n                // セルのタイプを取得\n                if (cell.model.type) {\n                    cellType = cell.model.type;\n                }\n            }\n            catch (error) {\n                this.logger.warn('Failed to get cell index or type:', error);\n            }\n            // Get execution results\n            let hasError = false;\n            let resultText = '';\n            let errorMessage = '';\n            let executionCount = undefined;\n            if (cell.outputArea) {\n                // 実行カウントを取得\n                try {\n                    executionCount = cell.model.executionCount || undefined;\n                }\n                catch (error) {\n                    this.logger.warn('Failed to get execution count:', error);\n                }\n                const outputs = cell.outputArea.model.toJSON();\n                for (const output of outputs) {\n                    if (output.output_type === 'error') {\n                        hasError = true;\n                        errorMessage = `${output.ename}: ${output.evalue}`;\n                        resultText = errorMessage;\n                        break;\n                    }\n                    else if (output.output_type === 'execute_result' || output.output_type === 'display_data') {\n                        if (output.data) {\n                            if (output.data['text/plain']) {\n                                resultText = output.data['text/plain'];\n                            }\n                        }\n                    }\n                }\n            }\n            // 実行時間の計測\n            const endTime = performance.now();\n            const executionDurationMs = Math.round(endTime - startTime);\n            // ユーザー情報を取得\n            const { emailAddress, userName, teamName } = this.settingsManager.getUserInfo();\n            // 新しいデータモデル\n            const progressData = {\n                eventId: generateUUID(),\n                eventType: 'cell_executed',\n                eventTime: new Date().toISOString(),\n                emailAddress,\n                teamName,\n                userName,\n                sessionId: this.sessionId,\n                notebookPath,\n                cellId,\n                cellIndex,\n                cellType: cellType,\n                code,\n                executionCount,\n                hasError,\n                errorMessage: hasError ? errorMessage : undefined,\n                result: resultText,\n                executionDurationMs\n            };\n            // データを送信\n            this.dataTransmissionService.sendProgressData([progressData]);\n        }\n        catch (error) {\n            handleCellProcessingError(error instanceof Error ? error : new Error(String(error)), 'Cell execution processing', { cellId: (_b = cell === null || cell === void 0 ? void 0 : cell.model) === null || _b === void 0 ? void 0 : _b.id });\n        }\n    }\n    /**\n     * ノートブックイベントを送信\n     */\n    async sendNotebookEvent(eventType, notebookPath) {\n        try {\n            const { emailAddress, userName, teamName } = this.settingsManager.getUserInfo();\n            const progressData = {\n                eventId: generateUUID(),\n                eventType,\n                eventTime: new Date().toISOString(),\n                emailAddress,\n                teamName,\n                userName,\n                sessionId: this.sessionId,\n                notebookPath\n            };\n            await this.dataTransmissionService.sendProgressData([progressData]);\n        }\n        catch (error) {\n            handleCellProcessingError(error instanceof Error ? error : new Error(String(error)), 'Notebook event transmission', { eventType, notebookPath });\n        }\n    }\n    /**\n     * ヘルプセッションを開始（Phase 2.3: 継続HELP送信対応）\n     */\n    startHelpSession() {\n        const currentWidget = this.notebookTracker.currentWidget;\n        if (!currentWidget) {\n            this.logger.warn('No notebook widget available for help session start');\n            return;\n        }\n        const notebookPath = currentWidget.context.path || 'unknown';\n        // 既に継続送信中の場合は何もしない\n        if (this.helpIntervals.has(notebookPath)) {\n            this.logger.debug('Help session already active', {\n                notebookPath: notebookPath.substring(0, 20) + '...'\n            });\n            return;\n        }\n        // 即座に最初のHELPを送信\n        this.sendHelpEvent(notebookPath);\n        // 10秒間隔での継続送信を開始\n        const interval = setInterval(() => {\n            this.sendHelpEvent(notebookPath);\n        }, 10000);\n        this.helpIntervals.set(notebookPath, interval);\n        this.helpSession.set(notebookPath, true);\n        this.helpSessionTimestamps.set(notebookPath, Date.now());\n        this.logger.info('Continuous help session started', {\n            notebookPath: notebookPath.substring(0, 20) + '...',\n            intervalId: 'set'\n        });\n        // UI通知\n        const { showNotifications } = this.settingsManager.getNotificationSettings();\n        if (showNotifications) {\n            Notification.info('継続ヘルプセッションを開始しました', { autoClose: 2000 });\n        }\n    }\n    /**\n     * ヘルプセッションを停止（Phase 2.3: バルククリーンアップ対応）\n     */\n    stopHelpSession() {\n        const currentWidget = this.notebookTracker.currentWidget;\n        if (!currentWidget) {\n            this.logger.warn('No notebook widget available for help session stop');\n            return;\n        }\n        const notebookPath = currentWidget.context.path || 'unknown';\n        // 継続送信を停止\n        const interval = this.helpIntervals.get(notebookPath);\n        if (interval) {\n            clearInterval(interval);\n            this.helpIntervals.delete(notebookPath);\n            this.logger.debug('Continuous help sending stopped', {\n                notebookPath: notebookPath.substring(0, 20) + '...'\n            });\n        }\n        // 最終のhelp_stopイベントを送信\n        this.sendHelpStopEvent(notebookPath);\n        // Phase 2.3: バルククリーンアップ実行（大幅メモリ削減）\n        this.bulkCleanupOldSessions();\n        this.helpSession.set(notebookPath, false);\n        // UI通知\n        const { showNotifications } = this.settingsManager.getNotificationSettings();\n        if (showNotifications) {\n            Notification.success('ヘルプセッション停止（メモリクリーンアップ実行）', { autoClose: 2000 });\n        }\n        this.logger.info('Help session stopped with bulk cleanup', {\n            notebookPath: notebookPath.substring(0, 20) + '...',\n            remainingSessions: this.helpSession.size\n        });\n    }\n    /**\n     * ノートブックのツールバーにヘルプボタンを追加（元のコードと同じ方式）\n     */\n    addHelpButtonToNotebook(widget) {\n        if (widget.toolbar) {\n            try {\n                // 既存のヘルプボタンを削除（重複防止）\n                const existingHelpButton = widget.toolbar.node.querySelector('.jp-help-button');\n                if (existingHelpButton) {\n                    this.logger.debug('Removing existing help button to prevent duplicates');\n                    existingHelpButton.remove();\n                }\n                const helpButton = this.createHelpButton();\n                widget.toolbar.addItem('help-button', helpButton);\n                this.logger.info('Help button added to notebook toolbar');\n            }\n            catch (error) {\n                handleUIError(error instanceof Error ? error : new Error(String(error)), 'Help button creation', 'ヘルプボタンの作成に失敗しました。');\n            }\n        }\n    }\n    /**\n     * ヘルプボタンを作成する（DOM安全版）\n     */\n    createHelpButton() {\n        this.logger.debug('Creating help button with DOM-safe implementation...');\n        const helpButton = new ToolbarButton({\n            className: 'jp-help-button jp-ToolbarButton',\n            onClick: () => {\n                this.logger.debug('Help button clicked!');\n                this.toggleHelpState(helpButton);\n            },\n            tooltip: 'ヘルプ要請ボタン - クリックでON/OFF切替',\n            label: '🆘 講師に助けを求める',\n            iconClass: 'jp-help-button__icon',\n            enabled: true\n        });\n        this.logger.debug('ToolbarButton created with persistent onClick handler');\n        return helpButton;\n    }\n    /**\n     * ヘルプ状態を切り替え（シンプルトグル）\n     */\n    toggleHelpState(button) {\n        const currentWidget = this.notebookTracker.currentWidget;\n        if (!currentWidget) {\n            Notification.warning('ノートブックが開かれていません');\n            return;\n        }\n        // UI状態で判定（シンプルで確実）\n        const isCurrentlyActive = button.node.classList.contains('jp-help-button--active');\n        this.logger.debug('toggleHelpState called, currently active:', isCurrentlyActive);\n        if (!isCurrentlyActive) {\n            // OFF → ON: 即座にUI切替 + 背景でサーバー通信\n            this.activateHelpButton(button);\n            this.startHelpSession(); // await削除、エラーは内部処理\n        }\n        else {\n            // ON → OFF: 即座にUI切替 + 背景でサーバー通信\n            this.deactivateHelpButton(button);\n            this.stopHelpSession(); // await削除、エラーは内部処理\n        }\n    }\n    /**\n     * ヘルプボタンをアクティブ状態に切り替え（DOM安全版）\n     */\n    activateHelpButton(button) {\n        // CSS状態変更（イベントハンドラー保持）\n        button.node.classList.add('jp-help-button--active');\n        // テキストコンテンツのみ変更（DOM構造保持）\n        const textElement = button.node.querySelector('.jp-ToolbarButtonComponent-label');\n        if (textElement) {\n            textElement.textContent = '🆘 ヘルプ要請中...';\n        }\n        // タイトル属性でツールチップ更新\n        button.node.setAttribute('title', 'ヘルプ要請中 - クリックで停止');\n        // 内部状態も更新\n        const currentWidget = this.notebookTracker.currentWidget;\n        if (currentWidget) {\n            const notebookPath = currentWidget.context.path || 'unknown';\n            this.helpSession.set(notebookPath, true);\n        }\n        this.logger.debug('Help button activated with DOM-safe method');\n    }\n    /**\n     * ヘルプボタンを非アクティブ状態に切り替え（DOM安全版）\n     */\n    deactivateHelpButton(button) {\n        // CSS状態変更（イベントハンドラー保持）\n        button.node.classList.remove('jp-help-button--active');\n        // テキストコンテンツのみ変更（DOM構造保持）\n        const textElement = button.node.querySelector('.jp-ToolbarButtonComponent-label');\n        if (textElement) {\n            textElement.textContent = '🆘 講師に助けを求める';\n        }\n        // タイトル属性でツールチップ更新\n        button.node.setAttribute('title', 'ヘルプ要請ボタン - クリックでON/OFF切替');\n        // 内部状態も更新\n        const currentWidget = this.notebookTracker.currentWidget;\n        if (currentWidget) {\n            const notebookPath = currentWidget.context.path || 'unknown';\n            this.helpSession.set(notebookPath, false);\n        }\n        this.logger.debug('Help button deactivated with DOM-safe method');\n    }\n    /**\n     * Phase 2.3: 単一HELP送信（継続送信用）\n     */\n    sendHelpEvent(notebookPath) {\n        const { emailAddress, userName, teamName } = this.settingsManager.getUserInfo();\n        const progressData = {\n            eventId: generateUUID(),\n            eventType: 'help',\n            eventTime: new Date().toISOString(),\n            emailAddress,\n            teamName,\n            userName,\n            sessionId: this.sessionId,\n            notebookPath\n        };\n        // 背景でサーバー通信（エラーは内部処理のみ）\n        this.dataTransmissionService.sendProgressData([progressData])\n            .then(() => {\n            this.logger.debug('Continuous help event sent', {\n                notebookPath: notebookPath.substring(0, 20) + '...'\n            });\n        })\n            .catch((error) => {\n            this.logger.error('Failed to send continuous help event:', error);\n        });\n    }\n    /**\n     * Phase 2.3: HELP停止イベント送信\n     */\n    sendHelpStopEvent(notebookPath) {\n        const { emailAddress, userName, teamName } = this.settingsManager.getUserInfo();\n        const progressData = {\n            eventId: generateUUID(),\n            eventType: 'help_stop',\n            eventTime: new Date().toISOString(),\n            emailAddress,\n            teamName,\n            userName,\n            sessionId: this.sessionId,\n            notebookPath\n        };\n        // 背景でサーバー通信\n        this.dataTransmissionService.sendProgressData([progressData])\n            .then(() => {\n            this.logger.debug('Help stop event sent', {\n                notebookPath: notebookPath.substring(0, 20) + '...'\n            });\n        })\n            .catch((error) => {\n            this.logger.error('Failed to send help stop event:', error);\n        });\n    }\n    /**\n     * Phase 2.3: バルククリーンアップ（大幅メモリ削減）\n     */\n    bulkCleanupOldSessions() {\n        const now = Date.now();\n        const cutoffTime = now - (30 * 60 * 1000); // 30分前\n        let removedCount = 0;\n        this.logger.debug('Starting bulk cleanup', {\n            totalSessions: this.helpSession.size,\n            cutoffTime: new Date(cutoffTime).toISOString()\n        });\n        // 30分以上前のセッションを全て削除\n        for (const [key, timestamp] of this.helpSessionTimestamps.entries()) {\n            if (timestamp < cutoffTime) {\n                this.helpSession.delete(key);\n                this.helpSessionTimestamps.delete(key);\n                // 対応するintervalも確認・削除\n                const interval = this.helpIntervals.get(key);\n                if (interval) {\n                    clearInterval(interval);\n                    this.helpIntervals.delete(key);\n                }\n                removedCount++;\n            }\n        }\n        // 緊急時のFIFO制限も併用（フェイルセーフ）\n        this.emergencyFIFOCleanup();\n        this.logger.info('Bulk cleanup completed', {\n            removedSessions: removedCount,\n            remainingSessions: this.helpSession.size,\n            memoryReduction: `${removedCount * 0.4}MB estimated`\n        });\n    }\n    /**\n     * Phase 2.3: 緊急時FIFO制限（フェイルセーフ機能）\n     */\n    emergencyFIFOCleanup() {\n        if (this.helpSession.size >= EventManager.MAX_HELP_SESSIONS) {\n            const firstKey = this.helpSession.keys().next().value;\n            if (firstKey) {\n                this.helpSession.delete(firstKey);\n                this.helpSessionTimestamps.delete(firstKey);\n                const interval = this.helpIntervals.get(firstKey);\n                if (interval) {\n                    clearInterval(interval);\n                    this.helpIntervals.delete(firstKey);\n                }\n                this.logger.debug('Emergency FIFO cleanup executed', {\n                    removedKey: firstKey.substring(0, 10) + '***',\n                    currentSize: this.helpSession.size\n                });\n            }\n        }\n    }\n    /**\n     * 新しいセッションを開始（Phase 2.3: 全クリーンアップ強化）\n     */\n    startNewSession() {\n        // 全ての継続送信を停止\n        for (const [, interval] of this.helpIntervals.entries()) {\n            clearInterval(interval);\n        }\n        this.helpIntervals.clear();\n        this.sessionId = generateUUID();\n        this.helpSession.clear();\n        this.helpSessionTimestamps.clear();\n        this.processedCells.clear();\n        // this.lastProcessedTime = 0;\n        this.logger.info('New session started with full cleanup:', {\n            sessionId: this.sessionId,\n            memoryCleanup: 'complete'\n        });\n    }\n}\n// private lastProcessedTime: number = 0; // 将来の実装用に残しておく\nEventManager.MAX_HELP_SESSIONS = 20; // Phase 2.3: 緊急時FIFO制限\n","import { createLogger, handleSettingsError } from '../utils';\n/**\n * チーム名バリデーション\n */\nfunction validateTeamName(teamName) {\n    const pattern = /^チーム([A-Z]|[1-9][0-9]?)$/;\n    if (!teamName) {\n        return { isValid: false, error: 'チーム名は必須です' };\n    }\n    if (!pattern.test(teamName)) {\n        return {\n            isValid: false,\n            error: 'チーム名は「チームA-Z」または「チーム1-99」の形式で入力してください（例: チームA, チーム1, チーム10）'\n        };\n    }\n    return { isValid: true };\n}\n/**\n * 設定管理クラス\n * JupyterLabの設定レジストリと連携してCell Monitor拡張機能の設定を管理\n */\nexport class SettingsManager {\n    constructor() {\n        this.settings = null;\n        this.logger = createLogger('SettingsManager');\n        // コンストラクタは空\n    }\n    /**\n     * 設定を初期化\n     */\n    async initialize(settingRegistry, pluginId) {\n        try {\n            this.settings = await settingRegistry.load(pluginId);\n            // 設定変更の監視とリアルタイムバリデーション\n            this.settings.changed.connect(() => {\n                this.validateAndUpdateSettings();\n            });\n            // リアルタイムバリデーション設定\n            this.setupRealtimeValidation(settingRegistry, pluginId);\n            // 初回設定読み込み\n            this.updateSettingsFromRegistry();\n            this.logger.info('Settings initialized successfully');\n        }\n        catch (error) {\n            handleSettingsError(error instanceof Error ? error : new Error(String(error)), 'Settings initialization', '設定の初期化に失敗しました。デフォルト設定で継続します。');\n        }\n    }\n    /**\n     * 設定レジストリから設定を更新\n     */\n    updateSettingsFromRegistry() {\n        if (!this.settings)\n            return;\n        try {\n            // 設定値を取得して内部状態を更新\n            const serverUrl = this.settings.get('serverUrl').composite;\n            const emailAddress = this.settings.get('emailAddress').composite;\n            const userName = this.settings.get('userName').composite;\n            const teamName = this.settings.get('teamName').composite;\n            const retryAttempts = this.settings.get('retryAttempts').composite;\n            const showNotifications = this.settings.get('showNotifications').composite;\n            // チーム名のバリデーション\n            if (teamName) {\n                const validation = validateTeamName(teamName);\n                if (!validation.isValid) {\n                    this.logger.warn('Invalid team name detected:', validation.error);\n                    // 警告を表示（UI側で処理）\n                }\n            }\n            this.logger.debug('Settings updated from registry', {\n                serverUrl: serverUrl || 'default',\n                emailAddress: emailAddress || 'student001@example.com',\n                userName: userName || 'Anonymous',\n                teamName: teamName || 'チームA',\n                retryAttempts,\n                showNotifications\n            });\n        }\n        catch (error) {\n            this.logger.warn('Failed to update settings from registry:', error);\n        }\n    }\n    /**\n     * 現在の設定を取得\n     */\n    getSettings() {\n        return this.settings;\n    }\n    /**\n     * ユーザー情報を取得（バリデーション付き）\n     */\n    getUserInfo() {\n        if (!this.settings) {\n            return {\n                emailAddress: 'student001@example.com',\n                userName: 'Anonymous',\n                teamName: 'チームA'\n            };\n        }\n        const settingEmailAddress = this.settings.get('emailAddress').composite;\n        const settingUserName = this.settings.get('userName').composite;\n        const settingTeamName = this.settings.get('teamName').composite;\n        // チーム名のバリデーション\n        let validatedTeamName = settingTeamName || 'チームA';\n        if (settingTeamName) {\n            const validation = validateTeamName(settingTeamName);\n            if (!validation.isValid) {\n                this.logger.warn('Invalid team name, using default:', validation.error);\n                validatedTeamName = 'チームA'; // デフォルトにフォールバック\n            }\n        }\n        return {\n            emailAddress: settingEmailAddress || 'student001@example.com',\n            userName: settingUserName || 'Anonymous',\n            teamName: validatedTeamName\n        };\n    }\n    /**\n     * リアルタイムバリデーション設定\n     */\n    setupRealtimeValidation(_settingRegistry, _pluginId) {\n        // 設定エディタのDOMが変更された時の監視\n        // JupyterLabの設定UIが表示されたときに入力フィールドを監視\n        const observer = new MutationObserver((mutations) => {\n            mutations.forEach((mutation) => {\n                if (mutation.type === 'childList') {\n                    this.enhanceTeamNameInput();\n                }\n            });\n        });\n        // DOM全体を監視（設定UIが動的に生成されるため）\n        observer.observe(document.body, {\n            childList: true,\n            subtree: true\n        });\n    }\n    /**\n     * チーム名入力フィールドを強化\n     */\n    enhanceTeamNameInput() {\n        // JupyterLabの設定UIでチーム名フィールドを探す\n        const teamNameInputs = document.querySelectorAll('input[data-setting-path*=\"teamName\"]');\n        teamNameInputs.forEach((input) => {\n            if (input instanceof HTMLInputElement && !input.dataset.enhanced) {\n                input.dataset.enhanced = 'true';\n                // リアルタイム入力監視\n                input.addEventListener('input', (event) => {\n                    const target = event.target;\n                    const value = target.value;\n                    if (value) {\n                        const validation = validateTeamName(value);\n                        if (validation.isValid) {\n                            // 有効な入力の場合\n                            target.style.borderColor = '#4caf50';\n                            target.style.backgroundColor = '#f0f8f0';\n                            this.clearValidationMessage(target);\n                        }\n                        else {\n                            // 無効な入力の場合\n                            target.style.borderColor = '#f44336';\n                            target.style.backgroundColor = '#fdf0f0';\n                            this.showValidationMessage(target, validation.error || '');\n                        }\n                    }\n                    else {\n                        // 空の場合はリセット\n                        target.style.borderColor = '';\n                        target.style.backgroundColor = '';\n                        this.clearValidationMessage(target);\n                    }\n                });\n                // フォーカス時のヘルプメッセージ\n                input.addEventListener('focus', (event) => {\n                    const target = event.target;\n                    this.showHelpMessage(target);\n                });\n                // フォーカス外れ時のクリーンアップ\n                input.addEventListener('blur', (event) => {\n                    const target = event.target;\n                    this.clearHelpMessage(target);\n                });\n            }\n        });\n    }\n    /**\n     * バリデーションメッセージを表示\n     */\n    showValidationMessage(input, message) {\n        var _a;\n        this.clearValidationMessage(input);\n        const errorDiv = document.createElement('div');\n        errorDiv.className = 'team-name-validation-error';\n        errorDiv.style.cssText = `\n      color: #f44336;\n      font-size: 12px;\n      margin-top: 4px;\n      padding: 4px;\n      background-color: #ffebee;\n      border-radius: 4px;\n      border-left: 3px solid #f44336;\n    `;\n        errorDiv.textContent = message;\n        (_a = input.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(errorDiv, input.nextSibling);\n    }\n    /**\n     * バリデーションメッセージをクリア\n     */\n    clearValidationMessage(input) {\n        var _a;\n        const existingError = (_a = input.parentNode) === null || _a === void 0 ? void 0 : _a.querySelector('.team-name-validation-error');\n        if (existingError) {\n            existingError.remove();\n        }\n    }\n    /**\n     * ヘルプメッセージを表示\n     */\n    showHelpMessage(input) {\n        var _a;\n        this.clearHelpMessage(input);\n        const helpDiv = document.createElement('div');\n        helpDiv.className = 'team-name-help-message';\n        helpDiv.style.cssText = `\n      color: #1976d2;\n      font-size: 12px;\n      margin-top: 4px;\n      padding: 4px;\n      background-color: #e3f2fd;\n      border-radius: 4px;\n      border-left: 3px solid #1976d2;\n    `;\n        helpDiv.innerHTML = `\n      <strong>チーム名の形式:</strong><br>\n      • チームA〜Z (例: チームA, チームB)<br>\n      • チーム1〜99 (例: チーム1, チーム10)\n    `;\n        (_a = input.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(helpDiv, input.nextSibling);\n    }\n    /**\n     * ヘルプメッセージをクリア\n     */\n    clearHelpMessage(input) {\n        var _a;\n        const existingHelp = (_a = input.parentNode) === null || _a === void 0 ? void 0 : _a.querySelector('.team-name-help-message');\n        if (existingHelp) {\n            existingHelp.remove();\n        }\n    }\n    /**\n     * 設定変更時のバリデーションと更新\n     */\n    validateAndUpdateSettings() {\n        this.updateSettingsFromRegistry();\n        // 設定UI更新のための少し遅延した処理\n        setTimeout(() => {\n            this.enhanceTeamNameInput();\n        }, 100);\n    }\n    /**\n     * チーム名バリデーションメソッド（外部からアクセス可能）\n     */\n    validateTeamName(teamName) {\n        return validateTeamName(teamName);\n    }\n    /**\n     * サーバーURLを取得\n     */\n    getServerUrl() {\n        if (!this.settings) {\n            return 'http://localhost:8000/api/v1/events';\n        }\n        return this.settings.get('serverUrl').composite || 'http://localhost:8000/api/v1/events';\n    }\n    /**\n     * リトライ回数を取得\n     */\n    getRetryAttempts() {\n        if (!this.settings) {\n            return 3;\n        }\n        return this.settings.get('retryAttempts').composite || 3;\n    }\n    /**\n     * 通知設定を取得\n     */\n    getNotificationSettings() {\n        var _a;\n        if (!this.settings) {\n            return {\n                showNotifications: false,\n                animationEnabled: false\n            };\n        }\n        const showNotifications = this.settings.get('showNotifications').composite;\n        const animationEnabled = (_a = this.settings.get('animationEnabled')) === null || _a === void 0 ? void 0 : _a.composite;\n        return {\n            showNotifications: showNotifications !== undefined ? showNotifications : false,\n            animationEnabled: animationEnabled !== undefined ? animationEnabled : false\n        };\n    }\n}\n","/**\n * Cell Monitor JupyterLab Extension\n * リファクタリング版 - モジュール化されたアーキテクチャ\n */\nimport { ILabShell } from '@jupyterlab/application';\nimport { ToolbarButton, Notification } from '@jupyterlab/apputils';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\n// 新しいモジュール化されたインポート\nimport { SettingsManager } from './core/SettingsManager';\nimport { EventManager } from './core/EventManager';\nimport { DataTransmissionService } from './services/DataTransmissionService';\nimport { createLogger, handleInitializationError, errorHandler } from './utils';\n// プラグインの識別子\nconst PLUGIN_ID = 'cell-monitor:plugin';\n// プラグインのメイン機能を管理するクラス\nclass CellMonitorPlugin {\n    constructor(app, notebookTracker, settingRegistry, labShell) {\n        this.logger = createLogger('CellMonitorPlugin');\n        this.app = app;\n        // 依存関係を注入してインスタンスを作成\n        this.settingsManager = new SettingsManager();\n        this.dataTransmissionService = new DataTransmissionService(this.settingsManager);\n        this.eventManager = new EventManager(notebookTracker, this.settingsManager, this.dataTransmissionService);\n        this.initialize(settingRegistry, labShell);\n    }\n    /**\n     * プラグインの初期化\n     */\n    async initialize(settingRegistry, labShell) {\n        try {\n            this.logger.info('Initializing Cell Monitor extension...');\n            // 設定管理の初期化\n            await this.settingsManager.initialize(settingRegistry, PLUGIN_ID);\n            // 設定変更の監視（チーム名バリデーション）\n            this.setupSettingsValidation();\n            // エラーハンドラーの設定を更新\n            const { showNotifications } = this.settingsManager.getNotificationSettings();\n            errorHandler.configure({ showNotifications });\n            // イベント管理の初期化\n            this.eventManager.initialize();\n            // UIコンポーネントの初期化\n            this.setupToolbarButtons(labShell);\n            // 成功通知\n            if (showNotifications) {\n                Notification.success('Cell Monitor Extension Activated', { autoClose: 2000 });\n            }\n            this.logger.info('Cell Monitor extension activated successfully');\n        }\n        catch (error) {\n            handleInitializationError(error instanceof Error ? error : new Error(String(error)), 'Plugin initialization');\n            throw error; // JupyterLabに拡張機能の初期化失敗を知らせる\n        }\n    }\n    /**\n     * ツールバーボタンの設定\n     */\n    setupToolbarButtons(labShell) {\n        // 新しいセッション開始ボタンのみを作成（ヘルプボタンは各ノートブックに個別追加）\n        const newSessionButton = new ToolbarButton({\n            label: '新セッション',\n            tooltip: '新しい学習セッションを開始します',\n            onClick: () => this.startNewSession(),\n            className: 'jp-new-session-button'\n        });\n        // ツールバーに追加\n        this.app.shell.add(newSessionButton, 'top', { rank: 1001 });\n        this.logger.debug('New session button added to toolbar');\n    }\n    /**\n     * 設定バリデーションの監視設定\n     */\n    setupSettingsValidation() {\n        const settings = this.settingsManager.getSettings();\n        if (!settings)\n            return;\n        // 設定変更を監視\n        settings.changed.connect(() => {\n            const userInfo = this.settingsManager.getUserInfo();\n            const validation = this.settingsManager.validateTeamName(userInfo.teamName);\n            if (!validation.isValid) {\n                // バリデーションエラーの通知\n                Notification.error(`チーム名設定エラー: ${validation.error}`, { autoClose: 5000 });\n                this.logger.error('Team name validation failed:', validation.error);\n            }\n        });\n    }\n    /**\n     * 新しいセッションの開始\n     */\n    startNewSession() {\n        this.logger.info('Starting new learning session');\n        // セッション開始前にチーム名をバリデーション\n        const userInfo = this.settingsManager.getUserInfo();\n        const validation = this.settingsManager.validateTeamName(userInfo.teamName);\n        if (!validation.isValid) {\n            Notification.error(`セッション開始失敗: ${validation.error}`, { autoClose: 5000 });\n            return;\n        }\n        this.eventManager.startNewSession();\n        const { showNotifications: showSessionNotifications } = this.settingsManager.getNotificationSettings();\n        if (showSessionNotifications) {\n            Notification.success(`新しい学習セッションを開始しました (${userInfo.teamName})`, { autoClose: 2000 });\n        }\n    }\n}\n/**\n * JupyterLab拡張機能の定義\n */\nconst extension = {\n    id: PLUGIN_ID,\n    description: 'JupyterLab extension for cell execution monitoring',\n    autoStart: true,\n    requires: [INotebookTracker, ISettingRegistry, ILabShell],\n    activate: async (app, notebookTracker, settingRegistry, labShell) => {\n        // プラグインクラスのインスタンス化と初期化\n        new CellMonitorPlugin(app, notebookTracker, settingRegistry, labShell);\n    }\n};\n;\nexport default extension;\n","/**\n * データ送信サービス\n * APIへのデータ送信、再試行処理、通知表示を担当\n */\nimport axios from 'axios';\nimport { Notification } from '@jupyterlab/apputils';\nimport { createLogger, handleDataTransmissionError, handleNetworkError } from '../utils';\nimport { LoadDistributionService } from './LoadDistributionService';\n/**\n * データ送信サービス\n * 学習進捗データとレガシーセル実行データをサーバーに送信\n */\nexport class DataTransmissionService {\n    constructor(settingsManager) {\n        this.logger = createLogger('DataTransmissionService');\n        this.connectionPoolCleanupInterval = null;\n        // Phase 2.2: HTTP重複送信防止\n        this.pendingRequests = new Map();\n        this.settingsManager = settingsManager;\n        this.loadDistributionService = new LoadDistributionService(settingsManager);\n        // HTTP接続プール設定（Phase 2.1: 接続プール最適化）\n        // ブラウザ環境では Connection ヘッダーは自動管理されるため除外\n        this.axiosInstance = axios.create({\n            timeout: 8000,\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            maxRedirects: 3,\n            validateStatus: (status) => status < 500\n        });\n        // レガシー用接続プール\n        this.legacyAxiosInstance = axios.create({\n            timeout: 8000,\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            maxRedirects: 3,\n            validateStatus: (status) => status < 500\n        });\n        // 接続プールのクリーンアップ設定\n        this.setupConnectionPoolCleanup();\n    }\n    setupConnectionPoolCleanup() {\n        // 30秒ごとに接続プールの状況をログ出力（ブラウザでは自動クリーンアップされる）\n        this.connectionPoolCleanupInterval = setInterval(() => {\n            this.logger.debug('HTTP connection pool status check - automatic cleanup by browser');\n        }, 30000);\n    }\n    /**\n     * クリーンアップメソッド（必要に応じて呼び出し）\n     */\n    dispose() {\n        if (this.connectionPoolCleanupInterval) {\n            clearInterval(this.connectionPoolCleanupInterval);\n            this.connectionPoolCleanupInterval = null;\n        }\n        // Phase 2.2: 未完了のリクエストをクリーンアップ\n        this.pendingRequests.clear();\n        this.logger.debug('DataTransmissionService disposed', {\n            pendingRequestsCleared: true\n        });\n    }\n    /**\n     * 学習進捗データを送信（負荷分散機能付き + 重複送信防止）\n     */\n    async sendProgressData(data) {\n        if (data.length === 0)\n            return;\n        // Phase 2.2: 重複送信防止機能を適用\n        for (const event of data) {\n            await this.sendSingleEventWithDeduplication(event);\n        }\n    }\n    /**\n     * Phase 2.2: 重複送信防止付き単一イベント送信\n     */\n    async sendSingleEventWithDeduplication(event) {\n        var _a;\n        // 重複チェック用キー（セルID + イベントタイプ + タイムスタンプ分単位）\n        const timeKey = Math.floor(Date.now() / 60000); // 1分単位でキー生成\n        const requestKey = `${event.cellId || 'unknown'}-${event.eventType}-${timeKey}`;\n        // 既に同じリクエストが進行中なら待機\n        if (this.pendingRequests.has(requestKey)) {\n            this.logger.debug('Duplicate request detected, waiting...', {\n                cellId: ((_a = event.cellId) === null || _a === void 0 ? void 0 : _a.substring(0, 8)) + '...',\n                eventType: event.eventType,\n                requestKey: requestKey.substring(0, 20) + '...'\n            });\n            await this.pendingRequests.get(requestKey);\n            return;\n        }\n        // 新規リクエストを実行\n        const promise = this.sendSingleEventInternal([event]);\n        this.pendingRequests.set(requestKey, promise);\n        promise.finally(() => {\n            this.pendingRequests.delete(requestKey);\n        });\n        await promise;\n    }\n    /**\n     * Phase 2.2: 単一イベントの内部送信処理（負荷分散考慮）\n     */\n    async sendSingleEventInternal(data) {\n        // 負荷分散設定が有効な場合（デフォルトは有効）\n        let useLoadDistribution = true; // デフォルト値\n        try {\n            const settings = this.settingsManager.getSettings();\n            if (settings && settings.get) {\n                const loadDistSetting = settings.get('useLoadDistribution');\n                if (loadDistSetting && loadDistSetting.composite !== undefined) {\n                    useLoadDistribution = loadDistSetting.composite;\n                }\n            }\n        }\n        catch (error) {\n            this.logger.debug('Failed to get load distribution setting, using default', error);\n        }\n        if (useLoadDistribution) {\n            // 負荷分散付き送信\n            await this.loadDistributionService.sendWithLoadDistribution(data, (data) => this.sendProgressDataInternal(data));\n        }\n        else {\n            // 従来通りの送信\n            await this.sendProgressDataInternal(data);\n        }\n    }\n    /**\n     * 内部送信機能（既存ロジック）\n     */\n    async sendProgressDataInternal(data) {\n        const { showNotifications } = this.settingsManager.getNotificationSettings();\n        this.logger.debug('Sending progress data', {\n            eventCount: data.length,\n            showNotifications,\n            events: data.map(d => ({ eventType: d.eventType, eventId: d.eventId }))\n        });\n        const serverUrl = this.settingsManager.getServerUrl();\n        const maxRetries = this.settingsManager.getRetryAttempts();\n        let retries = 0;\n        while (retries <= maxRetries) {\n            try {\n                // Phase 2.1: 接続プール付きaxiosインスタンスを使用\n                await this.axiosInstance.post(serverUrl, data);\n                this.logger.info('Student progress data sent successfully', { eventCount: data.length });\n                if (data.length > 0 && showNotifications) {\n                    Notification.info(`Learning data sent (${data.length} events)`, {\n                        autoClose: 3000\n                    });\n                }\n                break;\n            }\n            catch (error) {\n                const errorObj = error instanceof Error ? error : new Error(String(error));\n                if (retries >= maxRetries) {\n                    handleDataTransmissionError(errorObj, 'Progress data transmission - max retries exceeded', { eventCount: data.length, retryAttempt: retries });\n                    break;\n                }\n                else {\n                    handleNetworkError(errorObj, `Progress data transmission - retry ${retries}/${maxRetries}`, undefined);\n                    // Wait before retrying (exponential backoff)\n                    await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, retries - 1)));\n                }\n                retries++;\n            }\n        }\n    }\n    /**\n     * レガシーセル実行データを送信（後方互換性のため）\n     */\n    async sendLegacyData(data) {\n        if (data.length === 0)\n            return;\n        const serverUrl = this.settingsManager.getServerUrl();\n        const legacyUrl = serverUrl.replace('student-progress', 'cell-monitor');\n        const maxRetries = this.settingsManager.getRetryAttempts();\n        let retries = 0;\n        while (retries <= maxRetries) {\n            try {\n                // Phase 2.1: レガシー用接続プール付きaxiosインスタンスを使用\n                await this.legacyAxiosInstance.post(legacyUrl, data);\n                this.logger.info('Legacy cell execution data sent successfully', { itemCount: data.length });\n                break;\n            }\n            catch (error) {\n                const errorObj = error instanceof Error ? error : new Error(String(error));\n                if (retries >= maxRetries) {\n                    handleDataTransmissionError(errorObj, 'Legacy data transmission - max retries exceeded', { itemCount: data.length, retryAttempt: retries });\n                    break;\n                }\n                else {\n                    handleNetworkError(errorObj, `Legacy data transmission - retry ${retries}/${maxRetries}`);\n                }\n                retries++;\n                // Wait before retrying (exponential backoff)\n                await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, retries - 1)));\n            }\n        }\n    }\n}\n","/**\n * 負荷分散サービス\n * 学生IDベースの一意な遅延により、サーバー負荷を分散\n */\nimport { createLogger } from '../utils/logger';\nexport class LoadDistributionService {\n    constructor(_settingsManager) {\n        this.logger = createLogger('LoadDistributionService');\n        // settingsManagerは将来の拡張で使用予定\n    }\n    /**\n     * 負荷分散付きデータ送信\n     */\n    async sendWithLoadDistribution(data, originalSendFunction) {\n        var _a, _b;\n        if (data.length === 0)\n            return;\n        // 動的遅延計算（セルID + タイムスタンプベース）\n        const userEmail = ((_a = data[0]) === null || _a === void 0 ? void 0 : _a.emailAddress) || '';\n        const cellId = ((_b = data[0]) === null || _b === void 0 ? void 0 : _b.cellId) || '';\n        const timestamp = Date.now();\n        const combinedSeed = `${userEmail}-${cellId}-${Math.floor(timestamp / 1000)}`;\n        const dynamicHash = this.hashString(combinedSeed);\n        const baseDelay = (dynamicHash % 2000) + 200; // 0.2-2.2秒で動的変動\n        this.logger.debug('Load distribution delay calculated', {\n            userEmail: userEmail.substring(0, 5) + '***', // プライバシー保護\n            delay: baseDelay,\n            eventCount: data.length\n        });\n        // 遅延実行\n        await new Promise(resolve => setTimeout(resolve, baseDelay));\n        // 既存の送信機能を実行（指数バックオフ付き）\n        await originalSendFunction(data);\n    }\n    /**\n     * 文字列ハッシュ関数（一意性確保）\n     */\n    hashString(str) {\n        if (!str)\n            return 0;\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            const char = str.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash; // 32bit整数に変換\n        }\n        return Math.abs(hash);\n    }\n}\n","/**\n * Error Handling Utilities for Cell Monitor Extension\n * Provides centralized error handling, reporting, and user-friendly messages\n */\nimport { Notification } from '@jupyterlab/apputils';\nimport { createLogger } from './logger';\nconst logger = createLogger('ErrorHandler');\n/**\n * Error severity levels\n */\nexport var ErrorSeverity;\n(function (ErrorSeverity) {\n    ErrorSeverity[\"LOW\"] = \"low\";\n    ErrorSeverity[\"MEDIUM\"] = \"medium\";\n    ErrorSeverity[\"HIGH\"] = \"high\";\n    ErrorSeverity[\"CRITICAL\"] = \"critical\";\n})(ErrorSeverity || (ErrorSeverity = {}));\n/**\n * Error categories for better classification\n */\nexport var ErrorCategory;\n(function (ErrorCategory) {\n    ErrorCategory[\"NETWORK\"] = \"network\";\n    ErrorCategory[\"SETTINGS\"] = \"settings\";\n    ErrorCategory[\"CELL_PROCESSING\"] = \"cell_processing\";\n    ErrorCategory[\"UI\"] = \"ui\";\n    ErrorCategory[\"DATA_TRANSMISSION\"] = \"data_transmission\";\n    ErrorCategory[\"INITIALIZATION\"] = \"initialization\";\n})(ErrorCategory || (ErrorCategory = {}));\nclass ErrorHandler {\n    constructor() {\n        this.config = {\n            showNotifications: true,\n            logToConsole: true,\n            reportToServer: false\n        };\n    }\n    /**\n     * Update error handler configuration\n     */\n    configure(config) {\n        this.config = { ...this.config, ...config };\n    }\n    /**\n     * Main error handling method\n     */\n    handle(errorInfo) {\n        const { error, category, severity, context, userMessage, shouldNotifyUser, metadata } = errorInfo;\n        // Log the error with appropriate level based on severity\n        this.logError(error, category, severity, context, metadata);\n        // Show user notification if needed\n        if (shouldNotifyUser && this.config.showNotifications) {\n            this.showUserNotification(userMessage || this.getDefaultUserMessage(category, severity), severity);\n        }\n        // Report to server if configured (future implementation)\n        if (this.config.reportToServer) {\n            this.reportError(errorInfo);\n        }\n    }\n    /**\n     * Log error with appropriate level\n     */\n    logError(error, category, severity, context, metadata) {\n        const logMessage = `[${category.toUpperCase()}] ${context ? `${context}: ` : ''}${error.message}`;\n        const logData = {\n            error: error.stack || error.message,\n            category,\n            severity,\n            context,\n            ...metadata\n        };\n        switch (severity) {\n            case ErrorSeverity.CRITICAL:\n            case ErrorSeverity.HIGH:\n                logger.error(logMessage, logData);\n                break;\n            case ErrorSeverity.MEDIUM:\n                logger.warn(logMessage, logData);\n                break;\n            case ErrorSeverity.LOW:\n                logger.info(logMessage, logData);\n                break;\n        }\n    }\n    /**\n     * Show user-friendly notifications\n     */\n    showUserNotification(message, severity) {\n        const options = { autoClose: this.getNotificationAutoClose(severity) };\n        switch (severity) {\n            case ErrorSeverity.CRITICAL:\n            case ErrorSeverity.HIGH:\n                Notification.error(message, options);\n                break;\n            case ErrorSeverity.MEDIUM:\n                Notification.warning(message, options);\n                break;\n            case ErrorSeverity.LOW:\n                Notification.info(message, options);\n                break;\n        }\n    }\n    /**\n     * Get auto-close duration based on severity\n     */\n    getNotificationAutoClose(severity) {\n        switch (severity) {\n            case ErrorSeverity.CRITICAL:\n                return 0; // Don't auto-close critical errors\n            case ErrorSeverity.HIGH:\n                return 10000; // 10 seconds\n            case ErrorSeverity.MEDIUM:\n                return 5000; // 5 seconds\n            case ErrorSeverity.LOW:\n                return 3000; // 3 seconds\n        }\n    }\n    /**\n     * Get default user message based on category and severity\n     */\n    getDefaultUserMessage(category, severity) {\n        const severityPrefix = severity === ErrorSeverity.CRITICAL || severity === ErrorSeverity.HIGH\n            ? '重要: ' : '';\n        switch (category) {\n            case ErrorCategory.NETWORK:\n                return `${severityPrefix}ネットワーク接続に問題があります。インターネット接続を確認してください。`;\n            case ErrorCategory.SETTINGS:\n                return `${severityPrefix}設定に問題があります。拡張機能の設定を確認してください。`;\n            case ErrorCategory.CELL_PROCESSING:\n                return `${severityPrefix}セル処理中にエラーが発生しました。しばらく待ってから再試行してください。`;\n            case ErrorCategory.UI:\n                return `${severityPrefix}画面表示でエラーが発生しました。画面を再読み込みしてください。`;\n            case ErrorCategory.DATA_TRANSMISSION:\n                return `${severityPrefix}データ送信でエラーが発生しました。自動的に再試行します。`;\n            case ErrorCategory.INITIALIZATION:\n                return `${severityPrefix}拡張機能の初期化でエラーが発生しました。JupyterLabを再起動してください。`;\n            default:\n                return `${severityPrefix}予期しないエラーが発生しました。`;\n        }\n    }\n    /**\n     * Report error to server (future implementation)\n     */\n    reportError(errorInfo) {\n        // TODO: Implement server error reporting\n        logger.debug('Error reporting to server not yet implemented', { errorInfo });\n    }\n}\n// Export singleton instance\nexport const errorHandler = new ErrorHandler();\n/**\n * Convenience functions for common error handling patterns\n */\n/**\n * Handle network errors\n */\nexport const handleNetworkError = (error, context, userMessage) => {\n    errorHandler.handle({\n        error,\n        category: ErrorCategory.NETWORK,\n        severity: ErrorSeverity.MEDIUM,\n        context,\n        userMessage,\n        shouldNotifyUser: true\n    });\n};\n/**\n * Handle settings errors\n */\nexport const handleSettingsError = (error, context, userMessage) => {\n    errorHandler.handle({\n        error,\n        category: ErrorCategory.SETTINGS,\n        severity: ErrorSeverity.HIGH,\n        context,\n        userMessage,\n        shouldNotifyUser: true\n    });\n};\n/**\n * Handle cell processing errors\n */\nexport const handleCellProcessingError = (error, context, metadata) => {\n    errorHandler.handle({\n        error,\n        category: ErrorCategory.CELL_PROCESSING,\n        severity: ErrorSeverity.LOW,\n        context,\n        shouldNotifyUser: false, // Don't spam users for cell processing errors\n        metadata\n    });\n};\n/**\n * Handle critical initialization errors\n */\nexport const handleInitializationError = (error, context) => {\n    errorHandler.handle({\n        error,\n        category: ErrorCategory.INITIALIZATION,\n        severity: ErrorSeverity.CRITICAL,\n        context,\n        shouldNotifyUser: true\n    });\n};\n/**\n * Handle UI errors\n */\nexport const handleUIError = (error, context, userMessage) => {\n    errorHandler.handle({\n        error,\n        category: ErrorCategory.UI,\n        severity: ErrorSeverity.MEDIUM,\n        context,\n        userMessage,\n        shouldNotifyUser: true\n    });\n};\n/**\n * Handle data transmission errors\n */\nexport const handleDataTransmissionError = (error, context, metadata) => {\n    errorHandler.handle({\n        error,\n        category: ErrorCategory.DATA_TRANSMISSION,\n        severity: ErrorSeverity.MEDIUM,\n        context,\n        shouldNotifyUser: true,\n        metadata\n    });\n};\n/**\n * Async error wrapper for promises\n */\nexport const withErrorHandling = (promise, category, severity = ErrorSeverity.MEDIUM, context) => {\n    return promise.catch(error => {\n        errorHandler.handle({\n            error: error instanceof Error ? error : new Error(String(error)),\n            category,\n            severity,\n            context,\n            shouldNotifyUser: severity >= ErrorSeverity.MEDIUM\n        });\n        throw error; // Re-throw to maintain promise chain behavior\n    });\n};\n/**\n * Sync error wrapper for functions\n */\nexport const withSyncErrorHandling = (fn, category, severity = ErrorSeverity.MEDIUM, context) => {\n    try {\n        return fn();\n    }\n    catch (error) {\n        errorHandler.handle({\n            error: error instanceof Error ? error : new Error(String(error)),\n            category,\n            severity,\n            context,\n            shouldNotifyUser: severity >= ErrorSeverity.MEDIUM\n        });\n        return undefined;\n    }\n};\n","/**\n * Logger utility for Cell Monitor Extension\n * Provides environment-based log level control and consistent logging interface\n */\nexport var LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n    LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"DEBUG\"] = 3] = \"DEBUG\";\n})(LogLevel || (LogLevel = {}));\nclass Logger {\n    constructor(config = {}) {\n        // Detect development mode (JupyterLab extension context)\n        this.isDevelopment = this.detectDevelopmentMode();\n        this.config = {\n            level: this.isDevelopment ? LogLevel.DEBUG : LogLevel.ERROR,\n            prefix: '[CellMonitor]',\n            enabledInProduction: false,\n            ...config\n        };\n    }\n    detectDevelopmentMode() {\n        // Check for development indicators\n        try {\n            // JupyterLab development mode usually has certain debug flags\n            if (typeof window !== 'undefined') {\n                // Check for development mode indicators\n                return (window.location.hostname === 'localhost' ||\n                    window.location.hostname === '127.0.0.1' ||\n                    document.querySelector('[data-jupyter-widgets-version]') !== null);\n            }\n            // For browser environments, assume development if on localhost\n            return false;\n        }\n        catch (_a) {\n            // Fallback to production mode if detection fails\n            return false;\n        }\n    }\n    shouldLog(level) {\n        if (!this.isDevelopment && !this.config.enabledInProduction) {\n            // In production, only allow ERROR level unless explicitly enabled\n            return level === LogLevel.ERROR;\n        }\n        return level <= this.config.level;\n    }\n    formatMessage(level, message, ...args) {\n        const timestamp = new Date().toISOString().split('T')[1].split('.')[0];\n        const prefix = `${this.config.prefix}[${level}][${timestamp}]`;\n        return [prefix, message, ...args];\n    }\n    error(message, ...args) {\n        if (this.shouldLog(LogLevel.ERROR)) {\n            console.error(...this.formatMessage('ERROR', message, ...args));\n        }\n    }\n    warn(message, ...args) {\n        if (this.shouldLog(LogLevel.WARN)) {\n            console.warn(...this.formatMessage('WARN', message, ...args));\n        }\n    }\n    info(message, ...args) {\n        if (this.shouldLog(LogLevel.INFO)) {\n            console.info(...this.formatMessage('INFO', message, ...args));\n        }\n    }\n    debug(message, ...args) {\n        if (this.shouldLog(LogLevel.DEBUG)) {\n            console.log(...this.formatMessage('DEBUG', message, ...args));\n        }\n    }\n    /**\n     * Special method for performance-sensitive debug logs\n     * These are completely removed in production builds\n     */\n    perfDebug(message, ...args) {\n        if (this.isDevelopment && this.shouldLog(LogLevel.DEBUG)) {\n            console.log(...this.formatMessage('PERF', message, ...args));\n        }\n    }\n    /**\n     * Group logging for complex debug scenarios\n     */\n    group(title, callback) {\n        if (this.shouldLog(LogLevel.DEBUG)) {\n            console.group(this.formatMessage('GROUP', title)[0]);\n            try {\n                callback();\n            }\n            finally {\n                console.groupEnd();\n            }\n        }\n    }\n    /**\n     * Create a child logger with additional context\n     */\n    child(context) {\n        return new Logger({\n            ...this.config,\n            prefix: `${this.config.prefix}[${context}]`\n        });\n    }\n}\n// Export singleton instance\nexport const logger = new Logger();\n// Export factory function for component-specific loggers\nexport const createLogger = (context) => {\n    return logger.child(context);\n};\n","/**\n * UUID生成ユーティリティ\n * RFC 4122準拠のUUID v4を生成する\n */\n/**\n * ユーティリティ関数: UUIDを生成する\n * @returns RFC 4122準拠のUUID v4文字列\n */\nexport function generateUUID() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        const r = Math.random() * 16 | 0;\n        const v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\n"],"names":[],"sourceRoot":""}